# Estrutura do Supabase para Sistema de Gestão Financeira

## 1. Tabelas da Base de Dados

### 1.1 Tabela: users (gerida pelo Supabase Auth)
```sql
-- Esta tabela é gerida automaticamente pelo Supabase Auth
-- Apenas precisamos estender com campos personalizados
ALTER TABLE auth.users ADD COLUMN IF NOT EXISTS username TEXT;
```

### 1.2 Tabela: empresas
```sql
CREATE TABLE empresas (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome VARCHAR(100) NOT NULL,
  tipo VARCHAR(50),
  descricao TEXT,
  data_criacao TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Índices
CREATE INDEX idx_empresas_user_id ON empresas(user_id);
CREATE INDEX idx_empresas_nome ON empresas(nome);

-- Políticas RLS (Row Level Security)
ALTER TABLE empresas ENABLE ROW LEVEL SECURITY;

-- Política: usuários só podem ver suas próprias empresas
CREATE POLICY "Usuários podem ver suas próprias empresas"
  ON empresas FOR SELECT
  USING (auth.uid() = user_id);

-- Política: usuários só podem inserir suas próprias empresas
CREATE POLICY "Usuários podem inserir suas próprias empresas"
  ON empresas FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Política: usuários só podem atualizar suas próprias empresas
CREATE POLICY "Usuários podem atualizar suas próprias empresas"
  ON empresas FOR UPDATE
  USING (auth.uid() = user_id);

-- Política: usuários só podem excluir suas próprias empresas
CREATE POLICY "Usuários podem excluir suas próprias empresas"
  ON empresas FOR DELETE
  USING (auth.uid() = user_id);
```

### 1.3 Tabela: clientes
```sql
CREATE TABLE clientes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome VARCHAR(100) NOT NULL,
  tipo VARCHAR(50),
  contacto VARCHAR(50),
  email VARCHAR(100),
  nif VARCHAR(20),
  notas TEXT,
  data_criacao TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Índices
CREATE INDEX idx_clientes_user_id ON clientes(user_id);
CREATE INDEX idx_clientes_nome ON clientes(nome);
CREATE INDEX idx_clientes_nif ON clientes(nif);

-- Políticas RLS
ALTER TABLE clientes ENABLE ROW LEVEL SECURITY;

-- Política: usuários só podem ver seus próprios clientes
CREATE POLICY "Usuários podem ver seus próprios clientes"
  ON clientes FOR SELECT
  USING (auth.uid() = user_id);

-- Política: usuários só podem inserir seus próprios clientes
CREATE POLICY "Usuários podem inserir seus próprios clientes"
  ON clientes FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Política: usuários só podem atualizar seus próprios clientes
CREATE POLICY "Usuários podem atualizar seus próprios clientes"
  ON clientes FOR UPDATE
  USING (auth.uid() = user_id);

-- Política: usuários só podem excluir seus próprios clientes
CREATE POLICY "Usuários podem excluir seus próprios clientes"
  ON clientes FOR DELETE
  USING (auth.uid() = user_id);
```

### 1.4 Tabela: categorias
```sql
CREATE TABLE categorias (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome VARCHAR(100) NOT NULL,
  tipo VARCHAR(20) NOT NULL CHECK (tipo IN ('receita', 'despesa')),
  descricao TEXT,
  data_criacao TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Índices
CREATE INDEX idx_categorias_user_id ON categorias(user_id);
CREATE INDEX idx_categorias_tipo ON categorias(tipo);

-- Políticas RLS
ALTER TABLE categorias ENABLE ROW LEVEL SECURITY;

-- Política: usuários só podem ver suas próprias categorias
CREATE POLICY "Usuários podem ver suas próprias categorias"
  ON categorias FOR SELECT
  USING (auth.uid() = user_id);

-- Política: usuários só podem inserir suas próprias categorias
CREATE POLICY "Usuários podem inserir suas próprias categorias"
  ON categorias FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Política: usuários só podem atualizar suas próprias categorias
CREATE POLICY "Usuários podem atualizar suas próprias categorias"
  ON categorias FOR UPDATE
  USING (auth.uid() = user_id);

-- Política: usuários só podem excluir suas próprias categorias
CREATE POLICY "Usuários podem excluir suas próprias categorias"
  ON categorias FOR DELETE
  USING (auth.uid() = user_id);
```

### 1.5 Tabela: transacoes
```sql
CREATE TABLE transacoes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tipo VARCHAR(20) NOT NULL CHECK (tipo IN ('receita', 'despesa')),
  valor_contribuinte DECIMAL(10, 2) NOT NULL DEFAULT 0,
  valor_bolso DECIMAL(10, 2) NOT NULL DEFAULT 0,
  descricao TEXT,
  foto_fatura VARCHAR(255),
  data_transacao DATE NOT NULL DEFAULT CURRENT_DATE,
  data_criacao TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  empresa_id BIGINT REFERENCES empresas(id) ON DELETE CASCADE NOT NULL,
  cliente_id BIGINT REFERENCES clientes(id) ON DELETE SET NULL,
  categoria_id BIGINT REFERENCES categorias(id) ON DELETE SET NULL,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE
);

-- Índices
CREATE INDEX idx_transacoes_user_id ON transacoes(user_id);
CREATE INDEX idx_transacoes_empresa_id ON transacoes(empresa_id);
CREATE INDEX idx_transacoes_cliente_id ON transacoes(cliente_id);
CREATE INDEX idx_transacoes_categoria_id ON transacoes(categoria_id);
CREATE INDEX idx_transacoes_tipo ON transacoes(tipo);
CREATE INDEX idx_transacoes_data ON transacoes(data_transacao);

-- Políticas RLS
ALTER TABLE transacoes ENABLE ROW LEVEL SECURITY;

-- Política: usuários só podem ver suas próprias transações
CREATE POLICY "Usuários podem ver suas próprias transações"
  ON transacoes FOR SELECT
  USING (auth.uid() = user_id);

-- Política: usuários só podem inserir suas próprias transações
CREATE POLICY "Usuários podem inserir suas próprias transações"
  ON transacoes FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Política: usuários só podem atualizar suas próprias transações
CREATE POLICY "Usuários podem atualizar suas próprias transações"
  ON transacoes FOR UPDATE
  USING (auth.uid() = user_id);

-- Política: usuários só podem excluir suas próprias transações
CREATE POLICY "Usuários podem excluir suas próprias transações"
  ON transacoes FOR DELETE
  USING (auth.uid() = user_id);
```

## 2. Funções RPC para Estatísticas

### 2.1 Função: get_estatisticas_resumo
```sql
CREATE OR REPLACE FUNCTION get_estatisticas_resumo(
  p_empresa_id BIGINT DEFAULT NULL,
  p_periodo VARCHAR DEFAULT 'mes',
  p_data_inicio DATE DEFAULT NULL,
  p_data_fim DATE DEFAULT NULL
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user_id UUID;
  v_receitas JSON;
  v_despesas JSON;
  v_saldo JSON;
  v_hoje DATE := CURRENT_DATE;
  v_inicio DATE;
  v_fim DATE;
BEGIN
  -- Obter o ID do usuário atual
  v_user_id := auth.uid();
  
  -- Definir período de datas
  IF p_periodo = 'dia' THEN
    v_inicio := v_hoje;
    v_fim := v_hoje;
  ELSIF p_periodo = 'mes' THEN
    v_inicio := DATE_TRUNC('month', v_hoje)::DATE;
    v_fim := (DATE_TRUNC('month', v_hoje) + INTERVAL '1 month' - INTERVAL '1 day')::DATE;
  ELSIF p_periodo = 'ano' THEN
    v_inicio := DATE_TRUNC('year', v_hoje)::DATE;
    v_fim := (DATE_TRUNC('year', v_hoje) + INTERVAL '1 year' - INTERVAL '1 day')::DATE;
  ELSIF p_periodo = 'personalizado' AND p_data_inicio IS NOT NULL AND p_data_fim IS NOT NULL THEN
    v_inicio := p_data_inicio;
    v_fim := p_data_fim;
  ELSE
    v_inicio := DATE_TRUNC('month', v_hoje)::DATE;
    v_fim := (DATE_TRUNC('month', v_hoje) + INTERVAL '1 month' - INTERVAL '1 day')::DATE;
  END IF;
  
  -- Calcular receitas
  SELECT json_build_object(
    'contribuinte', COALESCE(SUM(valor_contribuinte), 0),
    'bolso', COALESCE(SUM(valor_bolso), 0),
    'total', COALESCE(SUM(valor_contribuinte + valor_bolso), 0)
  ) INTO v_receitas
  FROM transacoes
  WHERE user_id = v_user_id
    AND tipo = 'receita'
    AND data_transacao BETWEEN v_inicio AND v_fim
    AND (p_empresa_id IS NULL OR empresa_id = p_empresa_id);
  
  -- Calcular despesas
  SELECT json_build_object(
    'contribuinte', COALESCE(SUM(valor_contribuinte), 0),
    'bolso', COALESCE(SUM(valor_bolso), 0),
    'total', COALESCE(SUM(valor_contribuinte + valor_bolso), 0)
  ) INTO v_despesas
  FROM transacoes
  WHERE user_id = v_user_id
    AND tipo = 'despesa'
    AND data_transacao BETWEEN v_inicio AND v_fim
    AND (p_empresa_id IS NULL OR empresa_id = p_empresa_id);
  
  -- Calcular saldo
  SELECT json_build_object(
    'contribuinte', (v_receitas->>'contribuinte')::DECIMAL - (v_despesas->>'contribuinte')::DECIMAL,
    'bolso', (v_receitas->>'bolso')::DECIMAL - (v_despesas->>'bolso')::DECIMAL,
    'total', (v_receitas->>'total')::DECIMAL - (v_despesas->>'total')::DECIMAL
  ) INTO v_saldo;
  
  -- Retornar resultado
  RETURN json_build_object(
    'receitas', v_receitas,
    'despesas', v_despesas,
    'saldo', v_saldo
  );
END;
$$;
```

### 2.2 Função: get_estatisticas_por_empresa
```sql
CREATE OR REPLACE FUNCTION get_estatisticas_por_empresa(
  p_periodo VARCHAR DEFAULT 'mes',
  p_data_inicio DATE DEFAULT NULL,
  p_data_fim DATE DEFAULT NULL
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user_id UUID;
  v_resultado JSON;
  v_hoje DATE := CURRENT_DATE;
  v_inicio DATE;
  v_fim DATE;
BEGIN
  -- Obter o ID do usuário atual
  v_user_id := auth.uid();
  
  -- Definir período de datas
  IF p_periodo = 'dia' THEN
    v_inicio := v_hoje;
    v_fim := v_hoje;
  ELSIF p_periodo = 'mes' THEN
    v_inicio := DATE_TRUNC('month', v_hoje)::DATE;
    v_fim := (DATE_TRUNC('month', v_hoje) + INTERVAL '1 month' - INTERVAL '1 day')::DATE;
  ELSIF p_periodo = 'ano' THEN
    v_inicio := DATE_TRUNC('year', v_hoje)::DATE;
    v_fim := (DATE_TRUNC('year', v_hoje) + INTERVAL '1 year' - INTERVAL '1 day')::DATE;
  ELSIF p_periodo = 'personalizado' AND p_data_inicio IS NOT NULL AND p_data_fim IS NOT NULL THEN
    v_inicio := p_data_inicio;
    v_fim := p_data_fim;
  ELSE
    v_inicio := DATE_TRUNC('month', v_hoje)::DATE;
    v_fim := (DATE_TRUNC('month', v_hoje) + INTERVAL '1 month' - INTERVAL '1 day')::DATE;
  END IF;
  
  -- Calcular estatísticas por empresa
  SELECT json_agg(
    json_build_object(
      'id', e.id,
      'nome', e.nome,
      'receitas', json_build_object(
        'contribuinte', COALESCE(rec.valor_contribuinte, 0),
        'bolso', COALESCE(rec.valor_bolso, 0),
        'total', COALESCE(rec.valor_contribuinte + rec.valor_bolso, 0)
      ),
      'despesas', json_build_object(
        'contribuinte', COALESCE(desp.valor_contribuinte, 0),
        'bolso', COALESCE(desp.valor_bolso, 0),
        'total', COALESCE(desp.valor_contribuinte + desp.valor_bolso, 0)
      ),
      'saldo', json_build_object(
        'contribuinte', COALESCE(rec.valor_contribuinte, 0) - COALESCE(desp.valor_contribuinte, 0),
        'bolso', COALESCE(rec.valor_bolso, 0) - COALESCE(desp.valor_bolso, 0),
        'total', (COALESCE(rec.valor_contribuinte, 0) + COALESCE(rec.valor_bolso, 0)) - 
                 (COALESCE(desp.valor_contribuinte, 0) + COALESCE(desp.valor_bolso, 0))
      )
    )
  ) INTO v_resultado
  FROM empresas e
  LEFT JOIN (
    SELECT 
      empresa_id, 
      SUM(valor_contribuinte) as valor_contribuinte, 
      SUM(valor_bolso) as valor_bolso
    FROM transacoes
    WHERE user_id = v_user_id
      AND tipo = 'receita'
      AND data_transacao BETWEEN v_inicio AND v_fim
    GROUP BY empresa_id
  ) rec ON e.id = rec.empresa_id
  LEFT JOIN (
    SELECT 
      empresa_id, 
      SUM(valor_contribuinte) as valor_contribuinte, 
      SUM(valor_bolso) as valor_bolso
    FROM transacoes
    WHERE user_id = v_user_id
      AND tipo = 'despesa'
      AND data_transacao BETWEEN v_inicio AND v_fim
    GROUP BY empresa_id
  ) desp ON e.id = desp.empresa_id
  WHERE e.user_id = v_user_id;
  
  -- Retornar resultado
  RETURN json_build_object('empresas', COALESCE(v_resultado, '[]'::JSON));
END;
$$;
```

### 2.3 Função: get_estatisticas_por_cliente
```sql
CREATE OR REPLACE FUNCTION get_estatisticas_por_cliente(
  p_empresa_id BIGINT DEFAULT NULL,
  p_periodo VARCHAR DEFAULT 'mes',
  p_data_inicio DATE DEFAULT NULL,
  p_data_fim DATE DEFAULT NULL
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user_id UUID;
  v_resultado JSON;
  v_hoje DATE := CURRENT_DATE;
  v_inicio DATE;
  v_fim DATE;
BEGIN
  -- Obter o ID do usuário atual
  v_user_id := auth.uid();
  
  -- Definir período de datas
  IF p_periodo = 'dia' THEN
    v_inicio := v_hoje;
    v_fim := v_hoje;
  ELSIF p_periodo = 'mes' THEN
    v_inicio := DATE_TRUNC('month', v_hoje)::DATE;
    v_fim := (DATE_TRUNC('month', v_hoje) + INTERVAL '1 month' - INTERVAL '1 day')::DATE;
  ELSIF p_periodo = 'ano' THEN
    v_inicio := DATE_TRUNC('year', v_hoje)::DATE;
    v_fim := (DATE_TRUNC('year', v_hoje) + INTERVAL '1 year' - INTERVAL '1 day')::DATE;
  ELSIF p_periodo = 'personalizado' AND p_data_inicio IS NOT NULL AND p_data_fim IS NOT NULL THEN
    v_inicio := p_data_inicio;
    v_fim := p_data_fim;
  ELSE
    v_inicio := DATE_TRUNC('month', v_hoje)::DATE;
    v_fim := (DATE_TRUNC('month', v_hoje) + INTERVAL '1 month' - INTERVAL '1 day')::DATE;
  END IF;
  
  -- Calcular estatísticas por cliente
  SELECT json_agg(
    json_build_object(
      'id', c.id,
      'nome', c.nome,
      'receitas', json_build_object(
        'contribuinte', COALESCE(rec.valor_contribuinte, 0),
        'bolso', COALESCE(rec.valor_bolso, 0),
        'total', COALESCE(rec.valor_contribuinte + rec.valor_bolso, 0)
      ),
      'despesas', json_build_object(
        'contribuinte', COALESCE(desp.valor_contribuinte, 0),
        'bolso', COALESCE(desp.valor_bolso, 0),
        'total', COALESCE(desp.valor_contribuinte + desp.valor_bolso, 0)
      ),
      'saldo', json_build_object(
        'contribuinte', COALESCE(rec.valor_contribuinte, 0) - COALESCE(desp.valor_contribuinte, 0),
        'bolso', COALESCE(rec.valor_bolso, 0) - COALESCE(desp.valor_bolso, 0),
        'total', (COALESCE(rec.valor_contribuinte, 0) + COALESCE(rec.valor_bolso, 0)) - 
                 (COALESCE(desp.valor_contribuinte, 0) + COALESCE(desp.valor_bolso, 0))
      )
    )
  ) INTO v_resultado
  FROM clientes c
  LEFT JOIN (
    SELECT 
      cliente_id, 
      SUM(valor_contribuinte) as valor_contribuinte, 
      SUM(valor_bolso) as valor_bolso
    FROM transacoes
    WHERE user_id = v_user_id
      AND tipo = 'receita'
      AND data_transacao BETWEEN v_inicio AND v_fim
      AND (p_empresa_id IS NULL OR empresa_id = p_empresa_id)
      AND cliente_id IS NOT NULL
    GROUP BY cliente_id
  ) rec ON c.id = rec.cliente_id
  LEFT JOIN (
    SELECT 
      cliente_id, 
      SUM(valor_contribuinte) as valor_contribuinte, 
      SUM(valor_bolso) as valor_bolso
    FROM transacoes
    WHERE user_id = v_user_id
      AND tipo = 'despesa'
      AND data_transacao BETWEEN v_inicio AND v_fim
      AND (p_empresa_id IS NULL OR empresa_id = p_empresa_id)
      AND cliente_id IS NOT NULL
    GROUP BY cliente_id
  ) desp ON c.id = desp.cliente_id
  WHERE c.user_id = v_user_id
    AND (rec.cliente_id IS NOT NULL OR desp.cliente_id IS NOT NULL);
  
  -- Adicionar transações sem cliente
  SELECT json_build_object(
    'id', NULL,
    'nome', 'Sem Cliente',
    'receitas', json_build_object(
      'contribuinte', COALESCE(SUM(CASE WHEN tipo = 'receita' THEN valor_contribuinte ELSE 0 END), 0),
      'bolso', COALESCE(SUM(CASE WHEN tipo = 'receita' THEN valor_bolso ELSE 0 END), 0),
      'total', COALESCE(SUM(CASE WHEN tipo = 'receita' THEN valor_contribuinte + valor_bolso ELSE 0 END), 0)
    ),
    'despesas', json_build_object(
      'contribuinte', COALESCE(SUM(CASE WHEN tipo = 'despesa' THEN valor_contribuinte ELSE 0 END), 0),
      'bolso', COALESCE(SUM(CASE WHEN tipo = 'despesa' THEN valor_bolso ELSE 0 END), 0),
      'total', COALESCE(SUM(CASE WHEN tipo = 'despesa' THEN valor_contribuinte + valor_bolso ELSE 0 END), 0)
    ),
    'saldo', json_build_object(
      'contribuinte', COALESCE(SUM(CASE WHEN tipo = 'receita' THEN valor_contribuinte ELSE -valor_contribuinte END), 0),
      'bolso', COALESCE(SUM(CASE WHEN tipo = 'receita' THEN valor_bolso ELSE -valor_bolso END), 0),
      'total', COALESCE(SUM(CASE WHEN tipo = 'receita' THEN valor_contribuinte + valor_bolso ELSE -(valor_contribuinte + valor_bolso) END), 0)
    )
  ) INTO v_resultado
  FROM transacoes
  WHERE user_id = v_user_id
    AND cliente_id IS NULL
    AND data_transacao BETWEEN v_inicio AND v_fim
    AND (p_empresa_id IS NULL OR empresa_id = p_empresa_id);
  
  -- Retornar resultado
  RETURN json_build_object('clientes', COALESCE(v_resultado, '[]'::JSON));
END;
$$;
```

### 2.4 Função: get_evolucao_mensal
```sql
CREATE OR REPLACE FUNCTION get_evolucao_mensal(
  p_ano INT DEFAULT EXTRACT(YEAR FROM CURRENT_DATE),
  p_empresa_id BIGINT DEFAULT NULL
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user_id UUID;
  v_resultado JSON;
  v_meses JSON[];
  v_mes_atual JSON;
  i INT;
BEGIN
  -- Obter o ID do usuário atual
  v_user_id := auth.uid();
  
  -- Inicializar array de meses
  v_meses := ARRAY[]::JSON[];
  
  -- Gerar dados para cada mês
  FOR i IN 1..12 LOOP
    -- Calcular estatísticas para o mês
    SELECT json_build_object(
      'mes', i,
      'nome_mes', TO_CHAR(TO_DATE(i::TEXT, 'MM'), 'TMMonth'),
      'receitas', json_build_object(
        'contribuinte', COALESCE(SUM(CASE WHEN tipo = 'receita' THEN valor_contribuinte ELSE 0 END), 0),
        'bolso', COALESCE(SUM(CASE WHEN tipo = 'receita' THEN valor_bolso ELSE 0 END), 0),
        'total', COALESCE(SUM(CASE WHEN tipo = 'receita' THEN valor_contribuinte + valor_bolso ELSE 0 END), 0)
      ),
      'despesas', json_build_object(
        'contribuinte', COALESCE(SUM(CASE WHEN tipo = 'despesa' THEN valor_contribuinte ELSE 0 END), 0),
        'bolso', COALESCE(SUM(CASE WHEN tipo = 'despesa' THEN valor_bolso ELSE 0 END), 0),
        'total', COALESCE(SUM(CASE WHEN tipo = 'despesa' THEN valor_contribuinte + valor_bolso ELSE 0 END), 0)
      ),
      'saldo', json_build_object(
        'contribuinte', COALESCE(SUM(CASE WHEN tipo = 'receita' THEN valor_contribuinte ELSE -valor_contribuinte END), 0),
        'bolso', COALESCE(SUM(CASE WHEN tipo = 'receita' THEN valor_bolso ELSE -valor_bolso END), 0),
        'total', COALESCE(SUM(CASE WHEN tipo = 'receita' THEN valor_contribuinte + valor_bolso ELSE -(valor_contribuinte + valor_bolso) END), 0)
      )
    ) INTO v_mes_atual
    FROM transacoes
    WHERE user_id = v_user_id
      AND EXTRACT(YEAR FROM data_transacao) = p_ano
      AND EXTRACT(MONTH FROM data_transacao) = i
      AND (p_empresa_id IS NULL OR empresa_id = p_empresa_id);
    
    -- Adicionar ao array de meses
    v_meses := v_meses || v_mes_atual;
  END LOOP;
  
  -- Retornar resultado
  RETURN json_build_object('evolucao_mensal', v_meses);
END;
$$;
```

### 2.5 Função: exportar_transacoes_csv
```sql
CREATE OR REPLACE FUNCTION exportar_transacoes_csv(
  p_empresa_id BIGINT DEFAULT NULL,
  p_cliente_id BIGINT DEFAULT NULL,
  p_tipo VARCHAR DEFAULT NULL,
  p_data_inicio DATE DEFAULT NULL,
  p_data_fim DATE DEFAULT NULL
)
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_user_id UUID;
  v_csv TEXT;
  v_header TEXT;
  v_row TEXT;
  v_result TEXT := '';
  r RECORD;
BEGIN
  -- Obter o ID do usuário atual
  v_user_id := auth.uid();
  
  -- Definir cabeçalho do CSV
  v_header := 'ID,Tipo,Valor Contribuinte (€),Valor Bolso (€),Data,Empresa,Cliente/Fornecedor,Descrição';
  v_result := v_result || v_header || E'\n';
  
  -- Buscar transações
  FOR r IN (
    SELECT 
      t.id,
      t.tipo,
      t.valor_contribuinte,
      t.valor_bolso,
      t.data_transacao,
      e.nome as empresa_nome,
      c.nome as cliente_nome,
      t.descricao
    FROM transacoes t
    JOIN empresas e ON t.empresa_id = e.id
    LEFT JOIN clientes c ON t.cliente_id = c.id
    WHERE t.user_id = v_user_id
      AND (p_empresa_id IS NULL OR t.empresa_id = p_empresa_id)
      AND (p_cliente_id IS NULL OR t.cliente_id = p_cliente_id)
      AND (p_tipo IS NULL OR t.tipo = p_tipo)
      AND (p_data_inicio IS NULL OR t.data_transacao >= p_data_inicio)
      AND (p_data_fim IS NULL OR t.data_transacao <= p_data_fim)
    ORDER BY t.data_transacao DESC
  ) LOOP
    -- Formatar linha do CSV
    v_row := r.id || ',' ||
             r.tipo || ',' ||
             r.valor_contribuinte || ',' ||
             r.valor_bolso || ',' ||
             TO_CHAR(r.data_transacao, 'DD/MM/YYYY') || ',' ||
             COALESCE('"' || REPLACE(r.empresa_nome, '"', '""') || '"', '') || ',' ||
             COALESCE('"' || REPLACE(r.cliente_nome, '"', '""') || '"', '') || ',' ||
             COALESCE('"' || REPLACE(r.descricao, '"', '""') || '"', '');
    
    -- Adicionar linha ao resultado
    v_result := v_result || v_row || E'\n';
  END LOOP;
  
  RETURN v_result;
END;
$$;
```

## 3. Buckets do Supabase Storage

### 3.1 Bucket: faturas
```sql
-- Criar bucket para armazenar faturas
INSERT INTO storage.buckets (id, name, public)
VALUES ('faturas', 'Faturas', false);

-- Política: usuários podem ver suas próprias faturas
CREATE POLICY "Usuários podem ver suas próprias faturas"
  ON storage.objects FOR SELECT
  USING (auth.uid()::TEXT = (storage.foldername(name))[1]);

-- Política: usuários podem inserir suas próprias faturas
CREATE POLICY "Usuários podem inserir suas próprias faturas"
  ON storage.objects FOR INSERT
  WITH CHECK (auth.uid()::TEXT = (storage.foldername(name))[1]);

-- Política: usuários podem atualizar suas próprias faturas
CREATE POLICY "Usuários podem atualizar suas próprias faturas"
  ON storage.objects FOR UPDATE
  USING (auth.uid()::TEXT = (storage.foldername(name))[1]);

-- Política: usuários podem excluir suas próprias faturas
CREATE POLICY "Usuários podem excluir suas próprias faturas"
  ON storage.objects FOR DELETE
  USING (auth.uid()::TEXT = (storage.foldername(name))[1]);
```

### 3.2 Bucket: temp
```sql
-- Criar bucket para arquivos temporários (importação/exportação)
INSERT INTO storage.buckets (id, name, public)
VALUES ('temp', 'Arquivos Temporários', false);

-- Política: usuários podem ver seus próprios arquivos temporários
CREATE POLICY "Usuários podem ver seus próprios arquivos temporários"
  ON storage.objects FOR SELECT
  USING (auth.uid()::TEXT = (storage.foldername(name))[1]);

-- Política: usuários podem inserir seus próprios arquivos temporários
CREATE POLICY "Usuários podem inserir seus próprios arquivos temporários"
  ON storage.objects FOR INSERT
  WITH CHECK (auth.uid()::TEXT = (storage.foldername(name))[1]);

-- Política: usuários podem atualizar seus próprios arquivos temporários
CREATE POLICY "Usuários podem atualizar seus próprios arquivos temporários"
  ON storage.objects FOR UPDATE
  USING (auth.uid()::TEXT = (storage.foldername(name))[1]);

-- Política: usuários podem excluir seus próprios arquivos temporários
CREATE POLICY "Usuários podem excluir seus próprios arquivos temporários"
  ON storage.objects FOR DELETE
  USING (auth.uid()::TEXT = (storage.foldername(name))[1]);
```

## 4. Dados Iniciais

### 4.1 Categorias Padrão
```sql
-- Função para criar categorias padrão para novos usuários
CREATE OR REPLACE FUNCTION criar_categorias_padrao()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Inserir categorias de receita
  INSERT INTO categorias (nome, tipo, descricao, user_id)
  VALUES 
    ('Vendas', 'receita', 'Receitas de vendas de produtos ou serviços', NEW.id),
    ('Outros', 'receita', 'Outras receitas', NEW.id);
  
  -- Inserir categorias de despesa
  INSERT INTO categorias (nome, tipo, descricao, user_id)
  VALUES 
    ('Fornecedores', 'despesa', 'Pagamentos a fornecedores', NEW.id),
    ('Salários', 'despesa', 'Pagamentos de salários', NEW.id),
    ('Impostos', 'despesa', 'Pagamentos de impostos', NEW.id),
    ('Outros', 'despesa', 'Outras despesas', NEW.id);
  
  RETURN NEW;
END;
$$;

-- Trigger para criar categorias padrão quando um novo usuário se registra
CREATE TRIGGER criar_categorias_padrao_trigger
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION criar_categorias_padrao();
```

### 4.2 Empresas Padrão
```sql
-- Função para criar empresas padrão para novos usuários
CREATE OR REPLACE FUNCTION criar_empresas_padrao()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Inserir empresas padrão
  INSERT INTO empresas (nome, tipo, descricao, user_id)
  VALUES 
    ('Nacional', 'Restaurante', 'Restaurante Nacional', NEW.id),
    ('Riverside', 'Restaurante', 'Restaurante Riverside', NEW.id),
    ('River Vibes', 'Restaurante', 'Restaurante River Vibes', NEW.id),
    ('Segmento Mutante', 'Serviços', 'Empresa de prestação de serviços', NEW.id);
  
  RETURN NEW;
END;
$$;

-- Trigger para criar empresas padrão quando um novo usuário se registra
CREATE TRIGGER criar_empresas_padrao_trigger
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION criar_empresas_padrao();
```
